using System.Text;
using System.Text.Json;

namespace GenerateHandlers;

/// <summary>
/// Generates AOT-friendly JSON protocol serializers for AWS services.
/// </summary>
internal sealed class JsonCodeGenerator
{
    private readonly string _serviceName;
    private readonly string _sdkNamespace;
    private readonly JsonElement _shapes;

    public JsonCodeGenerator(string serviceName, string sdkNamespace, JsonElement shapes)
    {
        _serviceName = serviceName;
        _sdkNamespace = sdkNamespace;
        _shapes = shapes;
    }

    public string GenerateSerializers(JsonElement operations)
    {
        var code = new StringBuilder();

        // File header
        code.AppendLine("// <auto-generated/>");
        code.AppendLine($"// Generated JSON protocol serializers for {_serviceName}");
        code.AppendLine("#nullable enable");
        code.AppendLine();
        code.AppendLine("using System.Text.Json;");
        code.AppendLine($"using {_sdkNamespace}.Model;");
        code.AppendLine();
        code.AppendLine("namespace LocalSqsSnsMessaging.Http.Handlers;");
        code.AppendLine();
        code.AppendLine("/// <summary>");
        code.AppendLine($"/// Generated JSON protocol serializers for {_serviceName} operations.");
        code.AppendLine("/// </summary>");
        code.AppendLine($"internal static class {_serviceName}JsonSerializers");
        code.AppendLine("{");

        // Generate operation-specific serializers
        foreach (var operation in operations.EnumerateObject())
        {
            var opName = operation.Name;
            var opValue = operation.Value;

            if (opValue.TryGetProperty("output", out var outputProp))
            {
                var outputShapeName = outputProp.GetProperty("shape").GetString()!;
                var outputShape = _shapes.GetProperty(outputShapeName);
                GenerateResponseSerializer(code, opName, outputShape);
            }
        }

        // Generate response dispatcher
        GenerateResponseDispatcher(code, operations);

        code.AppendLine("}");
        return code.ToString();
    }

    private static void GenerateResponseDispatcher(StringBuilder code, JsonElement operations)
    {
        code.AppendLine("    /// <summary>");
        code.AppendLine("    /// Dispatches response serialization to the appropriate operation-specific serializer.");
        code.AppendLine("    /// </summary>");
        code.AppendLine("    internal static string SerializeResponse(object response, string operationName)");
        code.AppendLine("    {");
        code.AppendLine("        return operationName switch");
        code.AppendLine("        {");

        foreach (var operation in operations.EnumerateObject())
        {
            var opName = operation.Name;
            if (operation.Value.TryGetProperty("output", out var _))
            {
                code.AppendLine($"            \"{opName}\" => Serialize{opName}Response(({opName}Response)response),");
            }
        }

        code.AppendLine($"            _ => throw new NotSupportedException($\"Operation '{{operationName}}' does not have a response serializer.\")");
        code.AppendLine("        };");
        code.AppendLine("    }");
        code.AppendLine();
    }

    private void GenerateResponseSerializer(StringBuilder code, string opName, JsonElement outputShape)
    {
        _itemCounter = 0; // Reset counter for each response serializer

        code.AppendLine($"    internal static string Serialize{opName}Response({opName}Response response)");
        code.AppendLine("    {");
        code.AppendLine("        using var stream = new System.IO.MemoryStream();");
        code.AppendLine("        using var writer = new Utf8JsonWriter(stream);");
        code.AppendLine("        writer.WriteStartObject();");
        code.AppendLine();

        if (outputShape.TryGetProperty("members", out var members))
        {
            foreach (var member in members.EnumerateObject())
            {
                var memberName = member.Name;
                var shapeName = member.Value.GetProperty("shape").GetString()!;
                var shape = _shapes.GetProperty(shapeName);
                var shapeType = shape.GetProperty("type").GetString()!;

                code.AppendLine($"        // {memberName}");
                GenerateSerializeMember(code, memberName, shapeName, shape, shapeType, "response");
                code.AppendLine();
            }
        }

        code.AppendLine("        writer.WriteEndObject();");
        code.AppendLine("        writer.Flush();");
        code.AppendLine("        return System.Text.Encoding.UTF8.GetString(stream.ToArray());");
        code.AppendLine("    }");
        code.AppendLine();
    }

    private void GenerateSerializeMember(StringBuilder code, string memberName, string shapeName, JsonElement shape, string shapeType, string sourceVar)
    {
        var csharpPropertyName = ToPascalCase(memberName);
        var jsonPropertyName = ToCamelCase(memberName);

        switch (shapeType)
        {
            case "string":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName} != null)");
                code.AppendLine($"            writer.WriteString(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName});");
                break;

            case "integer":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName}.HasValue)");
                code.AppendLine($"            writer.WriteNumber(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                break;

            case "long":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName}.HasValue)");
                code.AppendLine($"            writer.WriteNumber(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                break;

            case "boolean":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName}.HasValue)");
                code.AppendLine($"            writer.WriteBoolean(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                break;

            case "double":
            case "float":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName}.HasValue)");
                code.AppendLine($"            writer.WriteNumber(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                break;

            case "timestamp":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName}.HasValue)");
                code.AppendLine($"            writer.WriteString(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value.ToString(\"O\"));");
                break;

            case "list":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName} != null && {sourceVar}.{csharpPropertyName}.Count > 0)");
                code.AppendLine("        {");
                code.AppendLine($"            writer.WritePropertyName(\"{jsonPropertyName}\");");
                code.AppendLine("            writer.WriteStartArray();");

                // Get list member type
                var memberShape = shape.GetProperty("member").GetProperty("shape").GetString()!;
                var memberType = _shapes.GetProperty(memberShape).GetProperty("type").GetString()!;

                code.AppendLine($"            foreach (var item in {sourceVar}.{csharpPropertyName})");
                code.AppendLine("            {");

                if (memberType == "string")
                {
                    code.AppendLine("                writer.WriteStringValue(item);");
                }
                else if (memberType == "structure")
                {
                    // Serialize structure inline
                    code.AppendLine("                writer.WriteStartObject();");
                    GenerateStructureMembers(code, memberShape, "item", "                ");
                    code.AppendLine("                writer.WriteEndObject();");
                }
                else
                {
                    code.AppendLine($"                // TODO: Serialize {memberType}");
                }

                code.AppendLine("            }");
                code.AppendLine("            writer.WriteEndArray();");
                code.AppendLine("        }");
                break;

            case "map":
                code.AppendLine($"        if ({sourceVar}.{csharpPropertyName} != null && {sourceVar}.{csharpPropertyName}.Count > 0)");
                code.AppendLine("        {");
                code.AppendLine($"            writer.WritePropertyName(\"{jsonPropertyName}\");");
                code.AppendLine("            writer.WriteStartObject();");

                // Get map value type
                var valueShape = shape.GetProperty("value").GetProperty("shape").GetString()!;
                var valueType = _shapes.GetProperty(valueShape).GetProperty("type").GetString()!;

                code.AppendLine($"            foreach (var kvp in {sourceVar}.{csharpPropertyName})");
                code.AppendLine("            {");

                if (valueType == "string")
                {
                    code.AppendLine("                writer.WriteString(kvp.Key, kvp.Value);");
                }
                else
                {
                    code.AppendLine($"                // TODO: Serialize {valueType} value");
                }

                code.AppendLine("            }");
                code.AppendLine("            writer.WriteEndObject();");
                code.AppendLine("        }");
                break;

            case "structure":
                code.AppendLine($"        // TODO: Implement structure serialization for {csharpPropertyName} ({shapeName})");
                break;

            default:
                code.AppendLine($"        // TODO: Implement {shapeType} serialization for {csharpPropertyName}");
                break;
        }
    }

    private int _itemCounter;

    private void GenerateStructureMembers(StringBuilder code, string shapeName, string sourceVar, string indent)
    {
        if (!_shapes.TryGetProperty(shapeName, out var shape))
        {
            code.AppendLine($"{indent}// Shape {shapeName} not found");
            return;
        }

        if (!shape.TryGetProperty("members", out var members))
        {
            return;
        }

        foreach (var member in members.EnumerateObject())
        {
            var memberName = member.Name;
            var memberShapeName = member.Value.GetProperty("shape").GetString()!;
            var memberShape = _shapes.GetProperty(memberShapeName);
            var memberType = memberShape.GetProperty("type").GetString()!;

            var csharpPropertyName = ToPascalCase(memberName);
            var jsonPropertyName = ToCamelCase(memberName);

            switch (memberType)
            {
                case "string":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName} != null)");
                    code.AppendLine($"{indent}    writer.WriteString(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName});");
                    break;

                case "integer":
                case "long":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName}.HasValue)");
                    code.AppendLine($"{indent}    writer.WriteNumber(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                    break;

                case "boolean":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName}.HasValue)");
                    code.AppendLine($"{indent}    writer.WriteBoolean(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                    break;

                case "double":
                case "float":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName}.HasValue)");
                    code.AppendLine($"{indent}    writer.WriteNumber(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value);");
                    break;

                case "timestamp":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName}.HasValue)");
                    code.AppendLine($"{indent}    writer.WriteString(\"{jsonPropertyName}\", {sourceVar}.{csharpPropertyName}.Value.ToString(\"O\"));");
                    break;

                case "map":
                    var valueShape = memberShape.GetProperty("value").GetProperty("shape").GetString()!;
                    var valueType = _shapes.GetProperty(valueShape).GetProperty("type").GetString()!;

                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName} != null && {sourceVar}.{csharpPropertyName}.Count > 0)");
                    code.AppendLine($"{indent}{{");
                    code.AppendLine($"{indent}    writer.WritePropertyName(\"{jsonPropertyName}\");");
                    code.AppendLine($"{indent}    writer.WriteStartObject();");
                    code.AppendLine($"{indent}    foreach (var kvp in {sourceVar}.{csharpPropertyName})");
                    code.AppendLine($"{indent}    {{");

                    if (valueType == "string")
                    {
                        code.AppendLine($"{indent}        writer.WriteString(kvp.Key, kvp.Value);");
                    }
                    else if (valueType == "structure")
                    {
                        code.AppendLine($"{indent}        writer.WritePropertyName(kvp.Key);");
                        code.AppendLine($"{indent}        writer.WriteStartObject();");
                        GenerateStructureMembers(code, valueShape, "kvp.Value", $"{indent}        ");
                        code.AppendLine($"{indent}        writer.WriteEndObject();");
                    }
                    else
                    {
                        code.AppendLine($"{indent}        // TODO: Serialize {valueType} value");
                    }

                    code.AppendLine($"{indent}    }}");
                    code.AppendLine($"{indent}    writer.WriteEndObject();");
                    code.AppendLine($"{indent}}}");
                    break;

                case "list":
                    var listMemberShape = memberShape.GetProperty("member").GetProperty("shape").GetString()!;
                    var listMemberType = _shapes.GetProperty(listMemberShape).GetProperty("type").GetString()!;
                    var itemVarName = $"item{_itemCounter++}";

                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName} != null && {sourceVar}.{csharpPropertyName}.Count > 0)");
                    code.AppendLine($"{indent}{{");
                    code.AppendLine($"{indent}    writer.WritePropertyName(\"{jsonPropertyName}\");");
                    code.AppendLine($"{indent}    writer.WriteStartArray();");
                    code.AppendLine($"{indent}    foreach (var {itemVarName} in {sourceVar}.{csharpPropertyName})");
                    code.AppendLine($"{indent}    {{");

                    if (listMemberType == "string")
                    {
                        code.AppendLine($"{indent}        writer.WriteStringValue({itemVarName});");
                    }
                    else if (listMemberType == "structure")
                    {
                        code.AppendLine($"{indent}        writer.WriteStartObject();");
                        GenerateStructureMembers(code, listMemberShape, itemVarName, $"{indent}        ");
                        code.AppendLine($"{indent}        writer.WriteEndObject();");
                    }
                    else if (listMemberType == "blob")
                    {
                        code.AppendLine($"{indent}        writer.WriteStringValue(Convert.ToBase64String({itemVarName}.ToArray()));");
                    }
                    else
                    {
                        code.AppendLine($"{indent}        // TODO: Serialize {listMemberType}");
                    }

                    code.AppendLine($"{indent}    }}");
                    code.AppendLine($"{indent}    writer.WriteEndArray();");
                    code.AppendLine($"{indent}}}");
                    break;

                case "structure":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName} != null)");
                    code.AppendLine($"{indent}{{");
                    code.AppendLine($"{indent}    writer.WritePropertyName(\"{jsonPropertyName}\");");
                    code.AppendLine($"{indent}    writer.WriteStartObject();");
                    GenerateStructureMembers(code, memberShapeName, $"{sourceVar}.{csharpPropertyName}", $"{indent}    ");
                    code.AppendLine($"{indent}    writer.WriteEndObject();");
                    code.AppendLine($"{indent}}}");
                    break;

                case "blob":
                    code.AppendLine($"{indent}if ({sourceVar}.{csharpPropertyName} != null)");
                    code.AppendLine($"{indent}    writer.WriteString(\"{jsonPropertyName}\", Convert.ToBase64String({sourceVar}.{csharpPropertyName}.ToArray()));");
                    break;

                default:
                    code.AppendLine($"{indent}// TODO: Serialize {memberType} for {csharpPropertyName}");
                    break;
            }
        }
    }

    private static string ToCamelCase(string str)
    {
        if (string.IsNullOrEmpty(str) || char.IsLower(str[0]))
            return str;
        return char.ToLowerInvariant(str[0]) + str.Substring(1);
    }

    private static string ToPascalCase(string str)
    {
        if (string.IsNullOrEmpty(str) || char.IsUpper(str[0]))
            return str;
        return char.ToUpperInvariant(str[0]) + str.Substring(1);
    }
}
