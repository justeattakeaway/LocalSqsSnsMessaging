using System.Text;
using System.Text.Json;
using GenerateHandlers;

if (args.Length == 0)
{
    Console.Error.WriteLine("Usage: GenerateHandlers <project-directory>");
    return 1;
}

var projectDir = args[0];
var serviceModelsDir = Path.Combine(projectDir, "ServiceModels");
var outputDir = Path.Combine(projectDir, "Http", "Handlers", "Generated");

Directory.CreateDirectory(outputDir);

Console.WriteLine("Generating operation handlers from AWS service models...");

// Generate SQS handler (JSON protocol)
GenerateJsonProtocolHandler(
    Path.Combine(serviceModelsDir, "sqs-2012-11-05.normal.json"),
    "Sqs",
    "Amazon.SQS",
    "IAmazonSQS",
    outputDir);

// Generate SNS handler (Query protocol)
GenerateQueryProtocolHandler(
    Path.Combine(serviceModelsDir, "sns-2010-03-31.normal.json"),
    "Sns",
    "Amazon.SimpleNotificationService",
    "IAmazonSimpleNotificationService",
    outputDir);

Console.WriteLine("Code generation completed successfully!");
return 0;

static void GenerateJsonProtocolHandler(string modelPath, string serviceName, string sdkNamespace, string clientType, string outputDir)
{
    Console.WriteLine($"  Processing {serviceName} (JSON protocol)...");

    var json = File.ReadAllText(modelPath);
    using var doc = JsonDocument.Parse(json);
    var root = doc.RootElement;

    var operations = root.GetProperty("operations");
    var shapes = root.GetProperty("shapes");

    // Generate the handler
    GenerateJsonHandler(serviceName, sdkNamespace, clientType, operations, outputDir);

    // Generate the serializers using the new generator
    var generator = new JsonCodeGenerator(serviceName, sdkNamespace, shapes);
    var serializersCode = generator.GenerateSerializers(operations);

    var outputPath = Path.Combine(outputDir, $"{serviceName}JsonSerializers.g.cs");
    File.WriteAllText(outputPath, serializersCode);

    Console.WriteLine($"    Generated JSON protocol handler and serializers for {serviceName}");
}

static void GenerateJsonHandler(string serviceName, string sdkNamespace, string clientType, JsonElement operations, string outputDir)
{
    var code = new StringBuilder();
    code.AppendLine("// <auto-generated/>");
    code.AppendLine($"// Generated JSON protocol handler for {serviceName}");
    code.AppendLine();
    code.AppendLine($"using {sdkNamespace};");
    code.AppendLine($"using {sdkNamespace}.Model;");
    code.AppendLine();
    code.AppendLine("namespace LocalSqsSnsMessaging.Http.Handlers;");
    code.AppendLine();
    code.AppendLine("/// <summary>");
    code.AppendLine($"/// Handles {serviceName} operations using JSON protocol with generated serializers.");
    code.AppendLine("/// </summary>");
    code.AppendLine($"internal static partial class {serviceName}OperationHandler");
    code.AppendLine("{");
    code.AppendLine("    public static async Task<(object Response, string OperationName)> HandleAsync(");
    code.AppendLine("        AwsRequestContext context,");
    code.AppendLine("        InMemoryAwsBus bus,");
    code.AppendLine("        CancellationToken cancellationToken)");
    code.AppendLine("    {");
    code.AppendLine("        ArgumentNullException.ThrowIfNull(context);");
    code.AppendLine("        ArgumentNullException.ThrowIfNull(bus);");
    code.AppendLine();
    code.AppendLine($"        using {clientType} client = bus.Create{serviceName}Client();");
    code.AppendLine();
    code.AppendLine("        return context.OperationName switch");
    code.AppendLine("        {");

    // Generate switch cases for each operation
    foreach (var operation in operations.EnumerateObject())
    {
        var opName = operation.Name;
        if (!operation.Value.TryGetProperty("input", out var input))
        {
            continue;
        }

        code.AppendLine($"            \"{opName}\" => await Handle{opName}Async(context, client, cancellationToken),");
    }

    code.AppendLine($"            _ => throw new NotSupportedException($\"{serviceName} operation '{{context.OperationName}}' is not supported.\")");
    code.AppendLine("        };");
    code.AppendLine("    }");
    code.AppendLine();

    // Generate individual handler methods
    foreach (var operation in operations.EnumerateObject())
    {
        var opName = operation.Name;
        if (!operation.Value.TryGetProperty("input", out var input))
        {
            continue;
        }

        var requestTypeName = $"{opName}Request";

        code.AppendLine($"    private static async Task<(object, string)> Handle{opName}Async(");
        code.AppendLine("        AwsRequestContext context,");
        code.AppendLine($"        {clientType} client,");
        code.AppendLine("        CancellationToken cancellationToken)");
        code.AppendLine("    {");
        code.AppendLine($"        var request = Serialization.AwsJsonRequestDeserializer.Deserialize<{requestTypeName}>(context.RequestBody);");
        code.AppendLine($"        var response = await client.{opName}Async(request, cancellationToken).ConfigureAwait(false);");
        code.AppendLine($"        return (response, \"{opName}\");");
        code.AppendLine("    }");
        code.AppendLine();
    }

    code.AppendLine("}");

    var outputPath = Path.Combine(outputDir, $"{serviceName}OperationHandler.g.cs");
    File.WriteAllText(outputPath, code.ToString());
}

static void GenerateQueryProtocolHandler(string modelPath, string serviceName, string sdkNamespace, string clientType, string outputDir)
{
    Console.WriteLine($"  Processing {serviceName} (Query protocol)...");

    var json = File.ReadAllText(modelPath);
    using var doc = JsonDocument.Parse(json);
    var root = doc.RootElement;

    var metadata = root.GetProperty("metadata");
    var operations = root.GetProperty("operations");
    var shapes = root.GetProperty("shapes");
    var xmlNamespace = metadata.GetProperty("xmlNamespace").GetString() ?? "";

    // Generate the handler
    GenerateQueryHandler(serviceName, sdkNamespace, clientType, operations, outputDir);

    // Generate the serializers using the new generator
    var generator = new QueryCodeGenerator(serviceName, sdkNamespace, xmlNamespace, shapes);
    var serializersCode = generator.GenerateSerializers(operations);

    var outputPath = Path.Combine(outputDir, $"{serviceName}QuerySerializers.g.cs");
    File.WriteAllText(outputPath, serializersCode);

    Console.WriteLine($"    Generated Query protocol handler and serializers for {serviceName}");
}

static void GenerateQueryHandler(string serviceName, string sdkNamespace, string clientType, JsonElement operations, string outputDir)
{
    var code = new StringBuilder();
    code.AppendLine("// <auto-generated/>");
    code.AppendLine($"// Generated Query protocol handler for {serviceName}");
    code.AppendLine();
    code.AppendLine($"using {sdkNamespace};");
    code.AppendLine($"using {sdkNamespace}.Model;");
    code.AppendLine();
    code.AppendLine("namespace LocalSqsSnsMessaging.Http.Handlers;");
    code.AppendLine();
    code.AppendLine("/// <summary>");
    code.AppendLine($"/// Handles {serviceName} operations using Query protocol with generated serializers.");
    code.AppendLine("/// </summary>");
    code.AppendLine($"internal static partial class {serviceName}OperationHandler");
    code.AppendLine("{");
    code.AppendLine("    public static async Task<(object Response, string OperationName)> HandleAsync(");
    code.AppendLine("        AwsRequestContext context,");
    code.AppendLine("        InMemoryAwsBus bus,");
    code.AppendLine("        CancellationToken cancellationToken)");
    code.AppendLine("    {");
    code.AppendLine("        ArgumentNullException.ThrowIfNull(context);");
    code.AppendLine("        ArgumentNullException.ThrowIfNull(bus);");
    code.AppendLine();
    code.AppendLine($"        using {clientType} client = bus.Create{serviceName}Client();");
    code.AppendLine();
    code.AppendLine("        return context.OperationName switch");
    code.AppendLine("        {");

    // Generate switch cases for each operation
    foreach (var operation in operations.EnumerateObject())
    {
        var opName = operation.Name;
        if (!operation.Value.TryGetProperty("input", out var input))
        {
            continue;
        }

        code.AppendLine($"            \"{opName}\" => await Handle{opName}Async(context, client, cancellationToken),");
    }

    code.AppendLine($"            _ => throw new NotSupportedException($\"{serviceName} operation '{{context.OperationName}}' is not supported.\")");
    code.AppendLine("        };");
    code.AppendLine("    }");
    code.AppendLine();

    // Generate individual handler methods
    foreach (var operation in operations.EnumerateObject())
    {
        var opName = operation.Name;
        if (!operation.Value.TryGetProperty("input", out var input))
        {
            continue;
        }

        var requestTypeName = $"{opName}Request";

        code.AppendLine($"    private static async Task<(object, string)> Handle{opName}Async(");
        code.AppendLine("        AwsRequestContext context,");
        code.AppendLine($"        {clientType} client,");
        code.AppendLine("        CancellationToken cancellationToken)");
        code.AppendLine("    {");
        code.AppendLine($"        var request = {serviceName}QuerySerializers.Deserialize{opName}Request(context.RequestBody);");
        code.AppendLine($"        var response = await client.{opName}Async(request, cancellationToken).ConfigureAwait(false);");
        code.AppendLine($"        return (response, \"{opName}\");");
        code.AppendLine("    }");
        code.AppendLine();
    }

    code.AppendLine("}");

    var outputPath = Path.Combine(outputDir, $"{serviceName}OperationHandler.g.cs");
    File.WriteAllText(outputPath, code.ToString());
}
